This notes contain all the important info gathered during the development of this project. I have code out of the box 
by Max but Redux hasn't applied yet. In this we learn step by step how to apply redux and work with react-redux library.

Tag v1.1 - Completed redux basics - This doens't contain async functionality

* * Set 1 work flow - Redux basics

1. Steps in general for redux :
   * The state is the universal state and is called central store. To the store, we pass reducer.
   * That reducer which we pass to store is called root reducer. We can combine multiple reducers into one, and 
     that combined one becomes the root reducer which is then passed into the store.
   * The action is dispatched into the reducer and the logic is written inside reducer which updates the store.
   * For example, if we want to increment the counter (counter is in store), then we dispatch increment action and 
     the increment logic is written in the reducer. This updates the store.

2. Let's now apply redux by installing the packages below:
    * npm install --save redux ---> for redux alone

   It's better to define the central store in index.js since that is where the application starts.  
   Here in index.js we define store and pass reducer as an argument as discussed in 1. above. The reducer code is 
   not stored here since it might grow, hence lets create a store folder and put the code there for reducer. We import 
   into index.js and pass it to store.
   Note : Reducer is a function that takes state and an action.  
   Let's next connect react to redux.

3. Let's connect redux to react. 
    * npm install --save react-redux ---> for react to work with redux
   Provider is imported from react-redux and this is wrapped around <App/> in the index.js. This Provider is used to 
   connect react to redux. 
   We then use connect (function that returns a hoc) to connect react component (where we need the data to be passed from/to store). In short, 
   all the components which likes to get the updates from store and send the data to the store via reducer needs to 
   be wrapped with connect function which returns a hoc.
   We pass two arguments to connect. The first one is mapStateToProps meaning which part of the state is important to us,
   and which actions do we need to dispatch.

4. Now that we have connected store to our Counter component through mapStateToProps, we will now dispatch actions to 
   modify the value of the counter in the store on the button clicks like increment, decrement and so on. Note that type
   is important and must be present in dispatch method.

5. We have dispatched INCREMENT function. Let's now implement dispatch actions for DECREMENT, ADD, and SUBTRACT.
   After implementing them, we now can remove the local state in Counter component which holds counter (we now get that)
   from store, and can also remove the logic responsible to modify the counter in Counter.js. 

6. We have hardcoded the number into the ADD and SUBTRACT actions but it would be good if we pass this as an argument.
   Let's implement this now.

7. Let's replace if statements with switch statements in the reducer. This makes code more readable.

8. Adding a button to store the result now. When we click this btn, we need the current result (at that particular time) 
   to be displayed on the unordered list below.

9. Implemented Store Result button functionality now. But we get a key error here in the li item in Counter.js. Unique 
   key should have been Implemented which we will do it now by modifying code a bit in the reducer.

10. Now that we have implemented Store Result button which stores the counter every time we click on this btn, lets now
    work on deleting the result in the list on clicking on the result.

11. Let's outsource action types. We have INCREMENT, DECREMENT, ADD, SUBTRACT which we are using in two places, one in
    component where action is dispatched and the other one is in the reducer where this action is used in switch statement.
    If we make a typo in any one place of these two, this doesnt work so, it's better to have this terms in a separate file 
    and then can be imported and use it in both these places. Let's add this in store folder in actions.js.

12. Let's now combine multiple reducers. State defined in the reducer has two properties counter and results. If you see carefully,
    the reducer here does two things in switch statements. One is to do counter related tasks like DECREMENT, INCREMENT,
    add and SUBTRACT. The other thing it does is to store and delete results, STORE_RESULTS and DELETE_RESULTS.
    It's a good idea to separate this reducer as two, one is for counter related and the other one is for results 
    related. Then we can combine these reducers. So, the reducers can be counter.js and results.js in the store.
    For combining multiple reducers we import combineReducers from redux in index.

* * Set 2 work flow - Redux advanced

13. Middleware - Middleware is added between dispatching an action and reaching the reducer. 

                                  Without Middleware                                                  
              
                  COMPONENT --dispatches--> ACTION --reaches--> REDUCER         


                                  With Middleware

      COMPONENT --dispatches--> ACTION --reaches--> MIDDLEWARE --reaches-->  REDUCER   
                                                        |
                                                        |
                                                        ^
                                    Code is modified here (ususally async code is implemented) and then 
                                    passed to reducer. We can create our own middleware (which I will be showing as well),
                                    but react does it well for us (I will show this later).

  Middleware is a term used for functions or code that is hooked into a process which gets executed as a part of that process
  without stopping it. So, we can add middleware and the action will still reach reducer. But we can do something with that 
  action (in the middleware) before it reaches reducer.

  So, if we are adding a middleware manually in our react project, then where to add it ?
  In the index.js we add logger and assign it to a function (middleware) which inturn returns another function and that also returns 
  another function. 
  Don't worry if this all seems confusing. Remember, the react gives us all this built in, but it's good to know how to 
  add this middleware manually. Watch video 314. Adding MiddleWares to get clarity.

14. We got an overall idea what exactly a middleware is and the use of it. To recall again, mw is a place where 
      action is dispatched when the next(action) is executed. 

      Middleware

                          we have access to  ------> store, next and action

                Before next(action) --- 1
                          The action is not yet dispatched and the store.getState() gives the state before action being dispatched

                After next(action) --- 2
                          The next(action) has been executed and the store.getState() gives the updated state where we can see the effect 
                          of action.

                In between 1 and 2, before calling next(action), we can call async code or do anything with our action, but once the 
                action is dispatched (in step 2 after next(action) is called) we can't do anything asynchronously like calling backend 
                and causing side-effects. So the best place to comunicate with backend is after step 1 and befofe step 2.
                
15. Now that we have an idea about middleware, we would like to see the changes of the state in step 1 and step 2 (above) for any actions dispatched.
    This can be done by console logs which I had done in previous (2 commits before this) commit 16. There I had shown console.log before step 2 and 
    after step 2. But it would be hard to rely on console.log everytime and its unnecessary overhead. Redux Devtools can make our life easy
    to view the state before and after dispatching actions.
    Link to devtools - https://github.com/zalmoxisus/redux-devtools-extension
    Watch the video 315. Using the Redux devtools to implement this.

16. Now that we have added redux devtools and looked at the store before and after dispatching different actions like ADD, SUBTRACT and so on,
    lets now look at how to add Async code with redux. This is the main part of advanced redux.

    Now let's think of storing result on a backend. we have result.js inside store folder which is the reducer which is responsible to 
    store the results.

    * * Part of store/result.js below
----------------------------
    const reducer = (state = initialState, action) => {

        switch (action.type) {
          case actionTypes.STORE_RESULT:
            return {
              ...state,
              results: state.results.concat({ id: new Date(), val: action.result })
            };
            ....
        }
    }
----------------------------

  * We don't have a backend to store result (STORE_RESULT), but we can simulate this by javascript timeout function.
  * Now you might think that we can do something like this (modifying above code to add timeout)

  ----------------------------
    const reducer = (state = initialState, action) => {

        switch (action.type) {
          case actionTypes.STORE_RESULT:

          // Adding timeout
          setTimeOut(()=>{
              return {
                // result to backend or whatever
              }
          },2000)



            return {
              ...state,
              results: state.results.concat({ id: new Date(), val: action.result })
            };
            ....
        }
    }
----------------------------

  * I've added timeout to this STORE_RESULT, but the fact is, this doesnt work. Because reducer doesn't support async code 
    and doesnt wait for 2 seconds or 2000 milliseconds in the timeout block. It just executes the rest of the code and 
    our purpose fails. Reducer doesn't support the concept of promise where we can execute something in .then() block.
    Then how to solve this? Where to add async code?

  * The answer is, we can add async code in ACTION CREATORS.

17. What is an action creator? We have actions.js file which defines differnt type of actions for ADD, SUBTRACT etc like

    export const INCREMENT = "INCREMENT";
    export const ADD = "ADD";
    export const SUBTRACT = "SUBTRACT";
    export const STORE_RESULT = "STORE_RESULT";

    These are action creators (code responsible to create an action). Actually, these are not directly dispatched but 
    the one which is currently dispatched is in the counter component like so,

    const mapDispatchToProps = (dispatch) => {
        return {
          onIncrementCounter: () => dispatch({ type: actionTypes.INCREMENT }),
          onDecrementCounter: () => dispatch({ type: actionTypes.DECREMENT }),
          onAddCounter: (value) => dispatch({ type: actionTypes.ADD, value: value })
          ...
        }
    }

    For introducing async code with redux, we are going to change this and write bit differently. But let's see 
    how to change the existing action creator for synchronous code. Let's do this for increment.

    // Code already existing

----------------------------
    --> Existing action creator - action.js

      export const INCREMENT = "INCREMENT";

    --> Existing action dispatching - Counter.js

      const mapDispatchToProps = (dispatch) => {
        return {
          onIncrementCounter: () => dispatch({ type: actionTypes.INCREMENT })
          ...
        }
      }
----------------------------

WE CHANGE THIS TO 

    // New type of writing action creator for increment

    --> New type of writing action creator - action.js

            export const INCREMENT = "INCREMENT";

        1.    export const increment = () => { // any payload goes in the brackets if any exisits
                return {
                  type: INCREMENT
                }
              }

    --> New type of action dispatching - Counter.js

          import {increment} from '../actions'; --> path of actions.js (Will now be moved inside store/actions folder)

          const mapDispatchToProps = (dispatch) => {
              return {
                onIncrementCounter: () => dispatch(increment()) ---> increment is the function name used in line 1 above, not that we are executing increment() here which gives us action object like before
                ...
              }
          }
  This is the new way to dispatch action for sync code. 
----------------------------
  

